{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Gummi Injection","google":"UA-37678776-2","tagline":"A lightweight dependency injection framework for Objective-C","body":"# Gummi Injection\r\n![Gummi Injection Logo](http://sschmid.com/Libs/Gummi-Injection/Gummi-Injection-128.png)\r\n\r\n## Description\r\nGummi Injection is a lightweight dependency injection framework for Objective-C.\r\n\r\n## Dependencies\r\nGummi-Injection uses [Gummi Reflection](http://sschmid.github.com/Gummi-Reflection) to inspect objects.\r\n\r\n## Features\r\n* Add and remove injection rules (mappings) at any time\r\n* One api for different kind of mappings ([injector map: to:])\r\n* Inject into existing objects\r\n* Extend injector context with modules\r\n* Add or remove modules at any time\r\n* Map blocks to classes or protocols\r\n* Map singletons and eager singletons\r\n* Handles circular dependencies for singletons\r\n* Injector can create unmapped dependencies, when they can be created like this [[MyObject alloc] init]\r\n* Specify a custom selector for objects to get notified when injection is complete\r\n\r\n## How to use Gummi Injection\r\n\r\n#### Get an injector\r\n\r\n```objective-c\r\n// Create your own injector\r\nGIInjector *injector = [[GIInjector alloc] init];\r\n\r\n// or use the shared injector\r\nGIInjector *injector = [GIInjector sharedInjector];\r\n```\r\n\r\n#### Add injection rules [injector map:object to:keyObject]\r\n\r\n```objective-c\r\n// Map classes\r\n[injector map:[MyImplementation class] to:@protocol(MyProtocol)];\r\n\r\n// You don't have to do this. Gummi Injection will figure it out itself.\r\n[injector map:[MyImplementation class] to:[MyImplementation class]];\r\n\r\n// But you could do this\r\n[injector map:[MyImplementation1 class] to:[MyImplementation2 class]];\r\n\r\n// Map instances\r\n[injector map:car to:[Car class]]\r\n[injector map:car to:@protocol(Vehicle)]\r\n\r\n// Map singletons and eager singletons.\r\n// Eager singletons will be instantiated immediately\r\n[injector mapEagerSingleton:[Service class] to:@protocol(RemoteService)];\r\n[injector mapSingleton:[Model class] to:[Model class]];\r\n\r\n// Map blocks\r\nid (^factoryBlock)(GIInjector *) = ^(GIInjector *injector) {\r\n    id stuff = [injector getObject:[SomeStuff class]];\r\n    Car *car = [[Car alloc] initWithStuff:stuff];\r\n    return car;\r\n};\r\n[injector map:factoryBlock to:@protocol(Vehicle)];\r\n\r\n// You can remove mappings at any time\r\n[injector unMap:[Service class] from:@protocol(RemoteService)];\r\n```\r\n\r\n#### Mark properties for injection with \"inject\"\r\n\r\n```objective-c\r\n@class Wheel;\r\n\r\n@interface Car : NSObject <Vehicle>\r\n@property(nonatomic, strong) Wheel *wheel1;\r\n@property(nonatomic, strong) Wheel *wheel2;\r\n@property(nonatomic, strong) Wheel *wheel3;\r\n@property(nonatomic, strong) Wheel *wheel4;\r\n@property(nonatomic) id <Motor> motor;\r\n@end\r\n\r\n@implementation Car\r\n\r\ninject(@\"wheel1\", @\"wheel2\", @\"wheel3\", @\"wheel4\", @\"motor\");\r\n\r\n// Optional selector gets performed, when injection is complete\r\ninjection_complete(@\"startEngine\")\r\n\r\n- (void)startEngine {\r\n    if (self.motor)\r\n        NSLog(@\"[%@] Brrrmmmmm....\", NSStringFromClass([self class]));\r\n}\r\n\r\n...\r\n@end\r\n```\r\n\r\n#### Create an object with all dependencies set\r\nWhen an object gets created by calling injector#getObject, all its dependencies will be satisfied as well.\r\n\r\n```objective-c\r\n// No need to set up rules for simple injections like Wheel\r\n// that can be created with alloc init.\r\n// For protocols there's no way to know which implementation to return -\r\n// we need to set up a rule for it.\r\n[injector map:[HybridMotor class] to:@protocol(Motor)];\r\n\r\nCar *car = [injector getObject:[Car class]];\r\n\r\n// or use protocols\r\n[injector map:[Car class] to:@protocol(Vehicle)];\r\nCar *car = [injector getObject:@protocol(Vehicle)];\r\n\r\n// or inject into existing objects\r\nCar *car = [[Car alloc] init];\r\n[injector injectIntoObject:car];\r\n\r\n// This will happen:\r\n// - getObject looks up type Car -> no rule set -> Instantiate Car and inject into object\r\n//     - Each Car wants Wheels\r\n//         - Look up type Wheel -> no rule set -> Instantiate Wheel and inject into object\r\n//     - Car wants <Motor>\r\n//         - Look up type <Motor> -> rule found: [HybridMotor class]\r\n//         - Instantiate HybridMotor and inject into object\r\n// Done\r\n\r\n```\r\n\r\n## Modules\r\nModules are a wrapper for related mappings. They extend the context of the injector and can be added and removed at any time.\r\n\r\n```objective-c\r\nGIModule *module = [[GameModule alloc] init];\r\n[injector addModule:module];\r\n\r\n// After the game, remove the Module by class\r\n[injector removeModuleClass:[GameModule class]];\r\n// or by instance\r\n[injector removeModule:gameModule];\r\n```\r\n\r\n```objective-c\r\n@interface GameModule : GIModule\r\n@end\r\n\r\n@implementation GameModule\r\n\r\n- (void)configure:(GIInjector *)injector {\r\n    [super configure:injector];\r\n\r\n    [self mapSingleton:[MyGameModel class]\r\n                    to:@protocol(GameModel)];\r\n    \r\n    // Example Service starts automatically on init\r\n    [self mapEagerSingleton:[MyRemoteService class]\r\n                         to:@protocol(RemoteService)];\r\n}\r\n\r\n- (void)unload {\r\n    // For convenience, close all connections to stop service\r\n    Service *service = [_injector getObject:@protocol(RemoteService)];\r\n    [service close];\r\n\r\n    [super unload];\r\n}\r\n\r\n- (void)dealloc {\r\n    NSLog(@\"Service and Model get dealloced with me.\");\r\n}\r\n\r\n@end\r\n```\r\n\r\n## Projects that use Gummi Injection\r\n* [Gummi Commander] (http://sschmid.github.com/Gummi-Commander) Event Command Mapping System for Objective-C"}