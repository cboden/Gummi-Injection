{"tagline":"A lightweight dependency injection framework for Objective-C.","name":"Gummi Injection","body":"## Gummi Injection\r\n![Gummi Injection Logo](http://sschmid.com/Libs/Gummi-Injection/Gummi-Injection-128.png)\r\n\r\nGummi Injection is a lightweight dependency injection framework for Objective-C.\r\n\r\n## Features\r\n* Add and remove injection rules (mappings) at any time\r\n* One api for different kind of mappings ([injector map: to:])\r\n* Inject into existing objects\r\n* Extend injector context with modules\r\n* Add or remove modules at any time\r\n* Map singletons and eager singletons\r\n* Handles circular dependencies for singletons\r\n* Injector can create unmapped dependencies, when they can be created like this [[MyObject alloc] init]\r\n* Specify custom selector for objects to get notified when injection is complete\r\n\r\n## How to use Gummi Injection\r\n\r\n#### Get an injector\r\n```objective-c\r\n// Create your own injector\r\nGIInjector *injector = [[GIInjector alloc] init];\r\n\r\n// or use the shared injector\r\nGIInjector *injector = [GIInjector sharedInjector];\r\n```\r\n\r\n#### Add injection rules [injector map:object to:keyObject]\r\n```objective-c\r\n// Map classes\r\n[injector map:[MyImplementation class] to:@protocol(MyProtocol)];\r\n\r\n// You don't have to do this. Gummi Injection will figure it out itself.\r\n[injector map:[MyImplementation class] to:[MyImplementation class]];\r\n\r\n// But you could do this\r\n[injector map:[MyImplementation1 class] to:[MyImplementation2 class]];\r\n\r\n// Map instances\r\n[injector map:car to:[Car class]]\r\n[injector map:car to:@protocol(Vehicle)]\r\n\r\n// Map singletons and eager singletons.\r\n// Eager singletons will be instantiated immediately\r\n[injector mapEagerSingleton:[Service class] to:@protocol(RemoteService)];\r\n[injector mapSingleton:[Model class] to:[Model class]];\r\n\r\n// You can remove mappings at any time\r\n[injector unMap:[Service class] from:@protocol(RemoteService)];\r\n```\r\n\r\n#### Mark properties for injection with \"inject\"\r\n```objective-c\r\n@interface Car : NSObject <Vehicle>\r\n@property(nonatomic, strong) Wheel *leftFrontWheel;\r\n@property(nonatomic, strong) Wheel *rightFrontWheel;\r\n@property(nonatomic, strong) Wheel *leftRearWheel;\r\n@property(nonatomic, strong) Wheel *rightRearWheel;\r\n@property(nonatomic) id <Motor> motor;\r\n@end\r\n\r\n\r\n@implementation Car\r\n\r\ninject(@\"leftFrontWheel\", @\"rightFrontWheel\", @\"leftRearWheel\", @\"rightRearWheel\", @\"motor\");\r\n\r\n// Optional selector gets performed, when injection is complete\r\ninjection_complete(@\"startEngine\")\r\n\r\n@synthesize leftFrontWheel = _leftFrontWheel;\r\n@synthesize rightFrontWheel = _rightFrontWheel;\r\n@synthesize leftRearWheel = _leftRearWheel;\r\n@synthesize rightRearWheel = _rightRearWheel;\r\n@synthesize motor = _motor;\r\n\r\n...\r\n@end\r\n```\r\n\r\n#### Create an object with all dependencies set\r\nWhen an object gets created by calling injector#getObject, all its dependencies will be satisfied as well.\r\n\r\n```objective-c\r\n// No need to set up rules for simple injections like Wheel that can be created with alloc init.\r\n// For protocols there's no way to know which implementation to return - we need to set up a rule for it.\r\n[injector map:[HybridMotor class] to:@protocol(Motor)];\r\n\r\nCar *car = [injector getObject:[Car class]];\r\n\r\n// or use protocols\r\n[injector map:[Car class] to:@protocol(Vehicle)];\r\nCar *car = [injector getObject:@protocol(Vehicle)];\r\n\r\n// or inject into existing objects\r\nCar *car = [[Car alloc] init];\r\n[injector injectIntoObject:car];\r\n```\r\n\r\n## Modules\r\nModules are a wrapper for related mappings. They extend the context of the injector and can be added and removed at any time.\r\n```objective-c\r\nGIModule *module = [[GameModule alloc] init];\r\n[injector addModule:module];\r\n\r\n// After the game, remove the Module by class\r\n[injector removeModuleClass:[GameModule class]];\r\n// or by instance\r\n[injector removeModule:gameModule];\r\n```\r\n\r\n```objective-c\r\n@interface GameModule : GIModule\r\n@end\r\n\r\n@implementation GameModule\r\n\r\n- (void)configure:(GIInjector *)injector {\r\n    [super configure:injector];\r\n\r\n    [self mapSingleton:[MyGameModel class] to:@protocol(GameModel)];\r\n    \r\n    // Example Service starts automatically on init\r\n    [self mapEagerSingleton:[MyRemoteService class] to:@protocol(RemoteService)];\r\n}\r\n\r\n- (void)unload {\r\n    // For convenience, close all connections to stop service\r\n    Service *service = [_injector getObject:@protocol(RemoteService)];\r\n    [service close];\r\n\r\n    [super unload];\r\n}\r\n\r\n- (void)dealloc {\r\n    NSLog(@\"Service and Model get dealloced with me.\");\r\n}\r\n\r\n@end\r\n```\r\n\r\n## Other projects using Gummi Injection\r\n\r\n* [Gummi Commander] (https://github.com/sschmid/Gummi-Commander) Event Command Mapping System for Objective-C\r\n\r\nIf you enjoy using Gummi Injection in your projects let me know, and I'll mention your projects here.\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":""}